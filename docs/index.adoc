= Building a custom selector

Custom selector is a special input type that allow editors to find and select content and data from custom data sources. 

This tutorial takes you through the steps of building a custom selector that integrates with the Google Books API. 

NOTE: As a bonus, it also demonstrates how you may expose the book data directly in Enonic's GraphQL API via transclusion.


== Requirements

NOTE: This tutorial assumes that you are already familiar with the basic concepts of building Enonic apps, and have already https://developer.enonic.com/start[installed Enonic CLI]

New to Enonic? Look into one of the following tutorials to get familiar with the platform:

* https://developer.enonic.com/docs/headless-cms-intro[CMS primer] 
* https://developer.enonic.com/docs/developer-101[Developer 101] 


== Create a project

To complete this tutorial, you may use an existing app, or follow the instructions below to create one.

. Create a new app with sample content using this command:

  enonic project create -r app-hmdb

. Deploy to a sandbox:
    
    cd <newprojectfolder>
    enonic project deploy

NOTE: The app should automatically create content in a new Content Studio project called "Headless Demo".


== Create a content type

With the application ready, lets kick it all off by creating a new content type. 

Add this file to your project: 

.src/main/resources/site/content-types/book-list/book-list.xml
[source,XML]
----
include::../src/main/resources/site/content-types/book-list/book-list.xml[]
----

The content type has a single "CustomSelector" input. Notice the service reference `<service>book-selector</service>` in the schema. 

For the custom selector to work, you will need to implement this service.

== Create a service

The back-end service for you custom selector will be implemented using a JavaScript controller.

Our example controller will require some additional Enonic libraries for communicating with the *Google Books API*, and caching of the results.

. Add these two lines to the end of dependencies{...} section in your build file:
+
.build.gradle
[source,Javascript]
----
include "com.enonic.lib:lib-http-client:3.2.1"
include "com.enonic.lib:lib-cache:2.1.1"
----
+
NOTE: Verify that you are using current versions of the libraries by visiting Enonic Market.
+
. Add the controller to your project:
+
.resources/services/book-selector/book-selector.js
[source,Javascript]
----
include::../src/main/resources/services/book-selector/book-selector.js[]
----

The controller uses the http-client to fetch content from the Google Books API, and returns it in a standard format to the custom selector interface.

=== Response format

NOTE: A custom selector service _must_ explicitly handle paging of items in your service based on `start` and `count` parameters of the `GET` request that will be sent to the service by the custom selector input.

The JSON response object from a custom selector service must implement the following format:

hits::
Array of item objects

count::
Number of items in response

total::
Total number of items

The `hits` array contains the objects that will be listed in the selector's dropdown. 
The hits object must comply to the following format:

id::
Unique Id of the option

displayName::
Option title

description:: (_optional_)
Detailed description

iconUrl:: (_optional_)
Path to the thumbnail image file

icon:: (_optional_)
Inline image content (for example, SVG)

.Sample JSON response:
[source,JSON]
{
  "hits": [
    {
      "id": 1,
      "displayName": "Option number 1",
      "description": "External SVG file is used as icon",
      "iconUrl": "\/admin\/portal\/edit\/draft\/_\/asset\/com.enonic.app.features:1524061998\/images\/number_1.svg"
    },
    {
      "id": 2,
      "displayName": "Option number 2",
      "description": "Inline SVG markup is used as icon",
      "icon": {
        "data": "<svg version=\"1.1\" xmlns=\"http:\/\/www.w3.org\/2000\/svg\" width=\"32\" height=\"32\" viewBox=\"0 0 32 32\"><path fill=\"#000\" d=\"M16 3c-7.18 0-13 5.82-13 13s5.82 13 13 13 13-5.82 13-13-5.82-13-13-13zM16 27c-6.075 0-11-4.925-11-11s4.925-11 11-11 11 4.925 11 11-4.925 11-11 11zM17.564 17.777c0.607-0.556 1.027-0.982 1.26-1.278 0.351-0.447 0.607-0.875 0.77-1.282 0.161-0.408 0.242-0.838 0.242-1.289 0-0.793-0.283-1.457-0.848-1.99s-1.342-0.8-2.331-0.8c-0.902 0-1.654 0.23-2.256 0.69s-0.96 1.218-1.073 2.275l1.914 0.191c0.036-0.56 0.173-0.96 0.41-1.201s0.555-0.361 0.956-0.361c0.405 0 0.723 0.115 0.952 0.345 0.23 0.23 0.346 0.56 0.346 0.988 0 0.387-0.133 0.779-0.396 1.176-0.195 0.287-0.727 0.834-1.592 1.64-1.076 0.998-1.796 1.799-2.16 2.403s-0.584 1.242-0.656 1.917h6.734v-1.781h-3.819c0.101-0.173 0.231-0.351 0.394-0.534 0.16-0.183 0.545-0.552 1.153-1.109z\"><\/path><\/svg>",
        "type": "image\/svg+xml"
      }
    }
  ],
  "count": 2,
  "total": 2
}

== Selecting books

With the new code deployed, you will be able to create a new "Book list" item in Content Studio, and try out the selector.

Searching "for dummies" should provide something like this:

image:images/custom-selector-books.png["Showing list of books afters searching in the custom selector"]

Try selecting some books, and saving your changes. Your content item will now store the ID's of the selected books within the `data.books` property of your content.


== Accessing the content

With a fresh set of "Book lists" created, you may access the content directly in the GraphQL API.

To access the content via GraphQL, run the following query from the `Query Playground` in Content Studio.

NOTE: If you don't see `Query playground` in the Content Studio menu, it has probably not been installed yet. Simply install the https://market.enonic.com/vendors/enonic/guillotine[Guillotine application], and it will appear.

[source,JSON]
----
TODO sample JSON
----
TODO sample image


== Customizing the GraphQL API

This is an optional part of the tutorial, and demonstrates how you may extend the GraphQL API to include the actual book data from the Google API.

This may be beneficial, as your front-end will not have to handle integrations with the Google Books API directly.

=== Setting up a custom API

In the above examples, you were using the standard Guillotine app, and the standard GraphQL API. Using the Guillotine library, you will be able to create your own version of the API.

Lets get the new API endpoint setup first.

. Add the following line to the dependencies{...} section of your build file:
+
.build.gradle
[source,Javascript]
----
...
        include "com.enonic.lib:lib-guillotine:6.0.5"
...
----
+
. Add a controller to your project:
+
.resources/controllers/customapi.js
[source,Javascript]
----
var guillotineLib = require('/lib/guillotine');
var graphQlLib = require('/lib/graphql');

var schema = guillotineLib.createSchema();

exports.post = function (req) {
 var body = JSON.parse(req.body);
 var result = JSON.stringify(graphQlLib.execute(schema, body.query, body.variables));
 return {
     contentType: 'application/json',
     body: JSON.stringify(result)
 };
};
----
+
. Finally, update `site.xml` with a mapping to expose the controller as an endpoint
+
.resources/site/site.xml
[source,Javascript]
----
TODO
----

After deploying the code, you should be able to access your endpoint. If you used the hmdb-app for your project, the API will now be available here:

    http://localhost:8080/site/hmdb/draft/hmdb/myapi

Visiting with your browser should give a 405 error, as GraphQL uses the HTTP POST method.

NOTE: Your controller can also implement a GET handler if desired. 

=== Adding a new Type

With the custom API deployed, you can now extend it with a new GraphQL type, representing the Google books.

In order to customize the API, you can use https://developer.enonic.com/docs/guillotine/stable/embed/extending[creationCallbacks].

NOTE: The full controller code is available at the end of this section

This is how you may Create a GraphQL Type for GoogleBook

[source,Javascript]
----
const context = guillotineLib.createContext();

context.types.googleBookType = context.schemaGenerator.createObjectType({
    name: 'GoogleBook',
    fields: {
        id: {
            type: graphQlLib.GraphQLString,
        },
        title: {
            type: graphQlLib.GraphQLString,
        },
        authors: {
            type: graphQlLib.list(graphQlLib.GraphQLString),
        }
    }
});
----

Once the new type is registered you may use it in the `creationCallbacks`:

[source,Javascript]
----
context.options.creationCallbacks = {
    'com_example_myproject_BookList_Data': (context, params) => {
        params.fields.books = {
            type: graphQlLib.list(context.types.googleBookType),
            resolve: (env) => {
                const bookIds = env.source['books'];
                const googleBooks = [];
                (bookIds || []).forEach(bookId => {
                    books.push(fetchBookById(bookId)) // make request to Google Books API
                });
                return googleBooks;
            }
        };
    },
};
----

NOTE: The `com_example_myproject_BookList_Data` must match the GraphQL type you want to override.


The final trick is to create the GraphQL schema. https://developer.enonic.com/docs/guillotine/stable/embed/extending[More details on extending schemas].

[source,Javascript]
----
function createSchema() {
    const context = guillotineLib.createContext();

    // create and register custom object types if needed

    return context.schemaGenerator.createSchema({
        query: createRootQueryType(context),
        dictionary: context.dictionary,
    });
}
----

Try it all in your project by replacing your existing controller with the following code:

.resources/controllers/customapi.js
[source,Javascript]
----
include::../src/main/resources/controllers/customapi.js[]
----

TIP: Need help? Ask questions on our https://discuss.enonic.com/[forum] visit our https://slack.enonic.com[community Slack].
